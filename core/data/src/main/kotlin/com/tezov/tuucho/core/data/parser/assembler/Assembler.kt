package com.tezov.tuucho.core.data.parser.assembler

import com.tezov.tuucho.core.data.database.Database
import com.tezov.tuucho.core.data.parser._system.MatcherProtocol
import com.tezov.tuucho.core.domain._system.JsonElementPath
import com.tezov.tuucho.core.domain._system.find
import com.tezov.tuucho.core.domain._system.replace
import com.tezov.tuucho.core.domain._system.toPath
import com.tezov.tuucho.core.domain.schema.IdSchema
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idObject
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idObjectOrNull
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idPutPrimitive
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idPutValue
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idSourceOrNull
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idValueOrNull
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.isIdAutoGenerated
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import org.koin.core.component.KoinComponent
import org.koin.core.component.inject

abstract class Assembler : MatcherProtocol, KoinComponent {
    abstract val dataBaseType: String

    protected val database: Database by inject()

    protected open val matchers: List<MatcherProtocol> = emptyList()
    protected open val childProcessors: List<Assembler> = emptyList()

    override fun accept(
        path: JsonElementPath,
        element: JsonElement
    ) = matchers.any { it.accept(path, element) }

    suspend fun process(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ) = with(element.find(path)) {
        when (this) {
            is JsonArray -> processArray(path, element, extraData)
            is JsonObject -> processObject(path, element, extraData)
            is JsonPrimitive -> processPrimitive(path, element, extraData)
        }
    }

    private suspend fun JsonArray.processArray(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ) = element.replace(
        path, map {
            (it as? JsonObject)?.assembleObject("".toPath(), it, extraData)
                ?: throw IllegalStateException("by design element inside array must be object")
        }.let(::JsonArray)
    )

    private suspend fun JsonObject.processObject(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ) = assembleObject(path, element, extraData)

    private suspend fun JsonPrimitive.processPrimitive(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ) = null

    private fun <T> List<T>.singleOrThrow(path: JsonElementPath): T? {
        if (size > 1)
            throw IllegalStateException("Only one child processor can accept the element at path $path")
        return firstOrNull()
    }

    protected open fun List<JsonObject>.rectify(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ): List<JsonObject>? = null

    protected open fun JsonObject.rectify(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ): JsonObject? = null

    private suspend fun JsonObject.assembleObject(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ): JsonElement {
        var current = retrieveAllRef(extraData.url, dataBaseType)?.let { refs ->
            (refs.rectify(path, element, extraData) ?: refs).merge()
        } ?: run {
            rectify(path, element, extraData)
        } ?: this

        current = current.toMutableMap().apply {
            // remove the source since all has been resolved and make id a primitive value
            idPutPrimitive(current.idObjectOrNull?.idValueOrNull)
        }.let(::JsonObject)

        var _element = element.replace(path, current)
        if (childProcessors.isNotEmpty()) {
            current.keys.forEach { childKey ->
                val childPath = path.child(childKey)
                childProcessors
                    .filter { it.accept(childPath, _element) }
                    .singleOrThrow(path)
                    ?.process(childPath, _element, extraData)
                    ?.also { _element = it }
            }
        }
        return _element
    }

    private suspend fun JsonObject.retrieveAllRef(
        url: String,
        type: String
    ): List<JsonObject>? {
        if (idObject.idSourceOrNull == null) return null
        var currentEntry = this
        val entries = mutableListOf(currentEntry)
        do {
            val idRef = currentEntry.idObject.idSourceOrNull
            val entity = idRef?.let { ref ->
                database.jsonEntity().find(type = type, url = url, id = ref)
                    ?: database.jsonEntity().findShared(type = type, id = ref)
            }
            if (entity != null) {
                currentEntry = entity.jsonObject
                entries.add(currentEntry)
            }
        } while (idRef != null && entity != null)
        return entries
    }

    private fun List<JsonObject>.merge() = when (this.size) {
        1 -> first()

        else -> {
            val mergedMap = mutableMapOf<String, JsonElement>()
            for (entry in this.asReversed()) {
                mergedMap.merge(entry)
            }
            mergedMap.let(::JsonObject)
        }
    }

    private fun MutableMap<String, JsonElement>.merge(other: Map<String, JsonElement>) {
        for ((key, value) in other) {
            val currentValue = this[key]
            this[key] = when {
                currentValue is JsonObject && value is JsonObject -> {
                    val merged = currentValue.toMutableMap()
                    when {
                        key == IdSchema.Key.id -> merged.mergeId(value)
                        else -> merged.merge(value)
                    }
                    JsonObject(merged)
                }

                else -> value
            }
        }
    }

    private fun MutableMap<String, JsonElement>.mergeId(other: Map<String, JsonElement>) {
        if (!JsonObject(this).isIdAutoGenerated && JsonObject(other).isIdAutoGenerated) {
            // id auto generated is weak against user id, so we remove it
            other.toMutableMap()
                .apply { idPutValue(null) }
                .let { merge(it) }
        } else merge(other)
    }
}