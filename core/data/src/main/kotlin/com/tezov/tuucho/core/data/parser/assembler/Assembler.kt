package com.tezov.tuucho.core.data.parser.assembler

import com.tezov.tuucho.core.data.database.Database
import com.tezov.tuucho.core.data.parser._system.MatcherProtocol
import com.tezov.tuucho.core.domain._system.JsonElementPath
import com.tezov.tuucho.core.domain._system.find
import com.tezov.tuucho.core.domain._system.replace
import com.tezov.tuucho.core.domain._system.toPath
import com.tezov.tuucho.core.domain.schema.SymbolData
import com.tezov.tuucho.core.domain.schema.common.IdSchema.Companion.idObject
import com.tezov.tuucho.core.domain.schema.common.IdSchema.Companion.idObjectOrNull
import com.tezov.tuucho.core.domain.schema.common.IdSchema.Companion.idPutPrimitive
import com.tezov.tuucho.core.domain.schema.common.IdSchema.Companion.idPutValue
import com.tezov.tuucho.core.domain.schema.common.IdSchema.Companion.idSourceOrNull
import com.tezov.tuucho.core.domain.schema.common.IdSchema.Companion.idValueOrNull
import com.tezov.tuucho.core.domain.schema.common.IdSchema.Companion.isIdAutoGenerated
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonObject
import org.koin.core.component.KoinComponent
import org.koin.core.component.inject

abstract class Assembler : MatcherProtocol, KoinComponent {
    abstract val dataBaseType: String

    protected val database: Database by inject()

    protected open val matchers: List<MatcherProtocol> = emptyList()
    protected open val childProcessors: List<Assembler> = emptyList()

    override fun accept(
        path: JsonElementPath,
        element: JsonElement
    ) = matchers.any { it.accept(path, element) }

    suspend fun process(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ) = with(element.find(path)) {
        when (this) {
            is JsonArray -> processArray(path, element, extraData)
            is JsonObject -> processObject(path, element, extraData)
            else -> throw IllegalStateException("primitive can't be resolved")
        }
    }

    private suspend fun JsonArray.processArray(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ) = element.replace(
        path, map {
            (it as? JsonObject)?.assembleObject("".toPath(), it, extraData)
                ?: throw IllegalStateException("by design element inside array must be object")
        }.let(::JsonArray)
    )

    private suspend fun JsonObject.processObject(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ) = assembleObject(path, element, extraData)

    private fun <T> List<T>.singleOrThrow(path: JsonElementPath): T? {
        if (size > 1)
            throw IllegalStateException("Only one child processor can accept the element at path $path")
        return firstOrNull()
    }

    protected open fun List<JsonObject>.rectify(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ): List<JsonObject> = this

    private suspend fun JsonObject.assembleObject(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ): JsonElement {
        val resolvedRefs = retrieveAllRef(extraData.url, dataBaseType)
            .rectify(path, element, extraData)
        val mergedRef = resolvedRefs.merge()
        var _element = element.replace(path, mergedRef)
        if (childProcessors.isNotEmpty()) {
            mergedRef.keys.forEach { childKey ->
                val childPath = path.child(childKey)
                childProcessors
                    .filter { it.accept(childPath, _element) }
                    .singleOrThrow(path)
                    ?.let { _element = it.process(childPath, _element, extraData) }
            }
        }
        return _element
    }

    private suspend fun JsonObject.retrieveAllRef(
        url: String,
        type: String
    ): List<JsonObject> {
        //TODO could be improved, if current doesn't have a source ref, just skip and return null
        var currentEntry = this
        val entries = mutableListOf(currentEntry)
        do {
            val idRef = resolveIdRef(
                currentEntry.idObject.idValueOrNull,
                currentEntry.idObject.idSourceOrNull
            )
            val entity = idRef?.let { ref ->
                database.jsonEntity().find(type = type, url = url, id = ref)
                    ?: database.jsonEntity().findShared(type = type, id = ref)
            }
            if (entity != null) {
                currentEntry = entity.jsonObject
                entries.add(currentEntry)
            }
        } while (idRef != null && entity != null)
        return entries
    }

    private fun resolveIdRef(id: String?, idFrom: String?) = when {
        id?.startsWith(SymbolData.ID_REF_INDICATOR) == true -> {
            id.removePrefix(SymbolData.ID_REF_INDICATOR)
        }

        idFrom != null -> {
            idFrom.removePrefix(SymbolData.ID_REF_INDICATOR)
        }

        else -> null
    }

    private fun List<JsonObject>.merge(): JsonObject {
        val mergedRef = when (this.size) {
            1 -> first()

            else -> {
                val mergedMap = mutableMapOf<String, JsonElement>()
                for (entry in this.asReversed()) {
                    mergedMap.merge(entry)
                }
                mergedMap.let(::JsonObject)
            }
        }
        return mergedRef.toMutableMap().apply {
            // remove the source since all has been resolved and make id a simple value
            idPutPrimitive(mergedRef.idObjectOrNull?.idValueOrNull)
        }.let(::JsonObject)
    }

    private fun MutableMap<String, JsonElement>.merge(other: Map<String, JsonElement>) {
        for ((key, value) in other) {
            val currentValue = this[key]
            this[key] = when {
                currentValue is JsonObject && value is JsonObject -> {
                    val merged = currentValue.toMutableMap()
                    when {
                        key == com.tezov.tuucho.core.domain.schema.common.IdSchema.Key.id -> merged.mergeId(value)
                        else -> merged.merge(value)
                    }
                    JsonObject(merged)
                }

                else -> value
            }
        }
    }

    private fun MutableMap<String, JsonElement>.mergeId(other: Map<String, JsonElement>) {
        if (!isIdAutoGenerated && other.isIdAutoGenerated) {
            // id auto generated is weak against user id, so we remove it
            other.toMutableMap()
                .apply { idPutValue(null) }
                .let { merge(it) }
        } else merge(other)
    }
}