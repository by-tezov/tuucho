package com.tezov.tuucho.core.data.parser.rectifier.texts

import com.tezov.tuucho.core.data.di.MaterialRectifierModule.Name
import com.tezov.tuucho.core.data.parser._system.MatcherProtocol
import com.tezov.tuucho.core.data.parser._system.isTypeOf
import com.tezov.tuucho.core.data.parser.rectifier.Rectifier
import com.tezov.tuucho.core.domain._system.JsonElementPath
import com.tezov.tuucho.core.domain._system.find
import com.tezov.tuucho.core.domain._system.string
import com.tezov.tuucho.core.domain._system.toPath
import com.tezov.tuucho.core.domain.schema.DimensionSchema
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idAddGroup
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idHasGroup
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idObjectOrNull
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idPut
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idPutNullIfMissing
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idPutObject
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idPutSource
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idPutValue
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idRawOrNull
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idSourceOrNull
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.idValueOrNull
import com.tezov.tuucho.core.domain.schema.IdSchema.Companion.isIdAutoGenerated
import com.tezov.tuucho.core.domain.schema.TextSchema.defaultPut
import com.tezov.tuucho.core.domain.schema.TypeSchema
import com.tezov.tuucho.core.domain.schema.TypeSchema.Companion.typePut
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.jsonArray
import kotlinx.serialization.json.jsonObject
import org.koin.core.component.inject

class TextRectifier : Rectifier() {

    override val matchers: List<MatcherProtocol> by inject(
        Name.Matcher.TEXT
    )

    override val childProcessors: List<Rectifier> by inject(
        Name.Processor.TEXT
    )

    override fun accept(
        path: JsonElementPath, element: JsonElement
    ) = (path.lastSegment() == null &&
            element is JsonArray &&
            element.all { it.isTypeOf(TypeSchema.Value.Type.text) }) || super.accept(path, element)

    override fun beforeAlterArray(
        path: JsonElementPath,
        element: JsonElement
    ) = with(element.find(path).jsonArray) {
        JsonArray(this.map { process("".toPath(), it) })
    }

    override fun beforeAlterObject(
        path: JsonElementPath,
        element: JsonElement
    ) = element.find(path).jsonObject.toMutableMap().apply {
        typePut(TypeSchema.Value.Type.text)
        idPutNullIfMissing()
    }.let(::JsonObject)

    override fun beforeAlterPrimitive(
        path: JsonElementPath,
        element: JsonElement
    ) = mutableMapOf<String, JsonElement>()
        .apply {
            typePut(TypeSchema.Value.Type.text)
            idPutNullIfMissing()
            defaultPut(element.find(path).string)
        }
        .let(::JsonObject)

    override fun afterAlterObject(
        path: JsonElementPath,
        element: JsonElement
    ): JsonElement? = with(element.find(path).jsonObject) {
        val (value, source) = rectifyIds()
        if (value == null && source == null) return null
        idObjectOrNull?.let { idObject ->
            val idUpdated = idObject.toMutableMap().apply {
                when {
                    value != null && source != null -> idPut(value, source)
                    value != null -> idPutValue(value)
                    else -> idPutSource(source)
                }
            }
            toMutableMap()
                .apply { idPutObject(idUpdated) }
                .let(::JsonObject)
        }
    }

    private fun JsonObject.rectifyIds(): Pair<String?, String?> {
        var value: String?
        var source: String?
        with(idRawOrNull as JsonObject) {
            value = idValueOrNull
                ?.takeIf { !it.idHasGroup() && !isIdAutoGenerated }
                ?.idAddGroup(DimensionSchema.Value.Group.common)
            source = idSourceOrNull
                ?.takeIf { !it.idHasGroup() }
                ?.idAddGroup(DimensionSchema.Value.Group.common)
        }
        return value to source
    }

}