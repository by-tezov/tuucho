package com.tezov.tuucho.core.data.parser.assembler

import com.tezov.tuucho.core.data.cache.database.Database
import com.tezov.tuucho.core.data.parser._schema.header.HeaderIdSchema
import com.tezov.tuucho.core.data.parser._schema.header.HeaderIdSchema.Companion.idObject
import com.tezov.tuucho.core.data.parser._schema.header.HeaderIdSchema.Companion.idObjectOrNull
import com.tezov.tuucho.core.data.parser._schema.header.HeaderIdSchema.Companion.idPutObject
import com.tezov.tuucho.core.data.parser._schema.header.HeaderIdSchema.Companion.idPutSource
import com.tezov.tuucho.core.data.parser._schema.header.HeaderIdSchema.Companion.idPutValue
import com.tezov.tuucho.core.data.parser._schema.header.HeaderIdSchema.Companion.idSourceOrNull
import com.tezov.tuucho.core.data.parser._schema.header.HeaderIdSchema.Companion.idValueOrNull
import com.tezov.tuucho.core.data.parser._schema.header.HeaderIdSchema.Companion.isIdAutoGenerated
import com.tezov.tuucho.core.data.parser._system.JsonElementPath
import com.tezov.tuucho.core.data.parser._system.Matcher
import com.tezov.tuucho.core.data.parser._system.find
import com.tezov.tuucho.core.data.parser._system.replace
import com.tezov.tuucho.core.data.parser._system.toPath
import com.tezov.tuucho.core.domain.model._system.SymbolDomain
import kotlinx.serialization.json.JsonArray
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonObject
import org.koin.core.component.inject

abstract class AssemblerBase : Assembler {

    protected val database: Database by inject()

    override val matchers: List<Matcher> = emptyList()
    override val childProcessors: List<Assembler> = emptyList()

    private fun <T> Sequence<T>.singleOrThrow(path: JsonElementPath): T? {
        val list = this.toList()
        if (list.size > 1)
            throw IllegalStateException("Only one child processor can accept the element at path $path")
        return list.firstOrNull()
    }

    override suspend fun process(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ) = with(element.find(path)) {
        when (this) {
            is JsonArray -> processArray(path, element, extraData)
            is JsonObject -> processObject(path, element, extraData)
            else -> throw IllegalStateException("primitive can't be resolved")
        }
    }

    private suspend fun JsonArray.processArray(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ) = element.replace(
        path, map {
            (it as? JsonObject)?.assembleObject("".toPath(), it, extraData)
                ?: throw IllegalStateException("by design element inside array must be object")
        }.let(::JsonArray)
    )

    private suspend fun JsonObject.processObject(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ) = assembleObject(path, element, extraData)

    protected open fun List<JsonObject>.rectify(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ): List<JsonObject> = this

    private suspend fun JsonObject.assembleObject(
        path: JsonElementPath,
        element: JsonElement,
        extraData: ExtraDataAssembler
    ): JsonElement {
        val resolvedRefs = retrieveAllRef(extraData.url, dataBaseType)
            .rectify(path, element, extraData)
        val mergedRef = resolvedRefs.merge()
        var _element = element.replace(path, mergedRef)
        if (childProcessors.isNotEmpty()) {
            mergedRef.keys.forEach { childKey ->
                val childPath = path.child(childKey)
                childProcessors.asSequence()
                    .filter { it.accept(childPath, _element) }
                    .singleOrThrow(path)
                    ?.let { _element = it.process(childPath, _element, extraData) }
            }
        }
        return _element
    }

    private suspend fun JsonObject.retrieveAllRef(
        url: String,
        type: String
    ): List<JsonObject> {
        //TODO could be improved, if current doesn't have a source ref, just skip and return null
        var currentEntry = this
        val entries = mutableListOf(currentEntry)
        do {
            val idRef = resolveIdRef(
                currentEntry.idObject.idValueOrNull,
                currentEntry.idObject.idSourceOrNull
            )
            val entity = idRef?.let { ref ->
                database.jsonEntity().find(type = type, url = url, id = ref)
                    ?: database.jsonEntity().findShared(type = type, id = ref)
            }
            if (entity != null) {
                currentEntry = entity.jsonObject
                entries.add(currentEntry)
            }
        } while (idRef != null && entity != null)
        return entries
    }

    private fun resolveIdRef(id: String?, idFrom: String?) = when {
        id?.startsWith(SymbolDomain.ID_REF_INDICATOR) == true -> {
            id.removePrefix(SymbolDomain.ID_REF_INDICATOR)
        }

        idFrom != null -> {
            idFrom.removePrefix(SymbolDomain.ID_REF_INDICATOR)
        }

        else -> null
    }

    private fun List<JsonObject>.merge(): JsonObject = when (this.size) {
        1 -> first()

        else -> {
            val mergedMap = mutableMapOf<String, JsonElement>()
            for (entry in this.asReversed()) {
                mergedMap.merge(entry)
            }
            // remove the source since all has been resolved
            mergedMap.idObjectOrNull?.toMutableMap()?.apply {
                idPutSource(null)
            }?.also { mergedMap.idPutObject(it) }
            mergedMap.let(::JsonObject)
        }
    }

    private fun MutableMap<String, JsonElement>.merge(other: Map<String, JsonElement>) {
        for ((key, value) in other) {
            val currentValue = this[key]
            this[key] = when {
                currentValue is JsonObject && value is JsonObject -> {
                    val merged = currentValue.toMutableMap()
                    when {
                        key == HeaderIdSchema.Name.id -> merged.mergeId(value)
                        else -> merged.merge(value)
                    }
                    JsonObject(merged)
                }

                else -> value
            }
        }
    }

    private fun MutableMap<String, JsonElement>.mergeId(other: Map<String, JsonElement>) {
        if (!isIdAutoGenerated && other.isIdAutoGenerated) {
            // id auto generated is weak against user id, so we remove it
            other.toMutableMap().apply {
                idPutValue(null)
            }.let { merge(it) }
        } else merge(other)
    }
}