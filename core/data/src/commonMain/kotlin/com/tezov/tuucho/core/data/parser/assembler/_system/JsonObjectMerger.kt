package com.tezov.tuucho.core.data.parser.assembler._system

import com.tezov.tuucho.core.domain.model.schema._system.SchemaScope
import com.tezov.tuucho.core.domain.model.schema._system.withScope
import com.tezov.tuucho.core.domain.model.schema.material.IdSchema
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.JsonObject

class JsonObjectMerger {

    fun merge(from: List<JsonObject>): JsonObject = when (from.size) {
        1 -> from.first()

        else -> {
            JsonNull.withScope(::SchemaScope).apply {
                for (entry in from.asReversed()) {
                    merge(entry)
                }
            }.collect()
        }
    }

    private fun SchemaScope.merge(next: JsonObject) {
        for ((key, nextChild) in next) {
            val previousChild = this[key]
            this[key] = when {
                previousChild is JsonObject && nextChild is JsonObject -> {
                    previousChild.withScope(::SchemaScope).apply {
                        when {
                            key == IdSchema.root -> mergeId(nextChild)
                            else -> merge(nextChild)
                        }
                    }.collect()
                }

                else -> nextChild
            }
        }
    }

    private fun SchemaScope.mergeId(next: JsonObject) {
        return next.withScope(IdSchema::Scope).apply {
            remove(IdSchema.Key.source) // we remove source, since previous is the source about to be merged
//            if (idAutoGenerated == true && this@mergeId.withScope(IdSchema::Scope).idAutoGenerated != true) {
//                // next id is auto-generated, we removed it since it weak against previous id not auto-generated
//                remove(IdSchema.Key.value)
//                remove(IdSchema.Key.id_auto_generated)
//            } // Enter in conflict with on demand because the id changed after the first resolution, id can't change.
        }.collect().let { merge(it) }
    }

}